/**
 * Autosolver Bug Fix End-to-End Tests
 * 
 * INTEGRATION TEST SUITE - Complete Autosolve Workflow Validation
 * 
 * These tests ensure the autosolver bug fix prevents incorrect cell placements
 * like the R1C2=1 scenario from Master's evidence. Tests cover the complete
 * journey from initial puzzle state to solved state with two-phase candidate fill.
 */

import { renderHook, act, waitFor } from '@testing-library/react'
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { useAutoSolve } from './useAutoSolve'
import { useSudokuGame } from './useSudokuGame'
import { getPuzzleForSeed } from '../lib/puzzles-data'
import { solveAll } from '../lib/solver-service'
import { validateBoard } from '../lib/dp-solver'

// =============================================================================
// MOCKS
// =============================================================================

// Mock solver service to control autosolve behavior
vi.mock('../lib/solver-service', () => ({
  solveAll: vi.fn(),
}))

// Mock puzzles-data to provide test puzzle from evidence
vi.mock('../lib/puzzles-data', () => ({
  getPuzzleForSeed: vi.fn(),
}))

// Mock validation to verify solution correctness
vi.mock('../lib/dp-solver', () => ({
  validateBoard: vi.fn(),
}))

// Import mocked functions for assertions
const mockSolveAll = vi.mocked(solveAll)
const mockGetPuzzleForSeed = vi.mocked(getPuzzleForSeed)
const mockValidateBoard = vi.mocked(validateBoard)

// =============================================================================
// TEST UTILITIES
// =============================================================================

/**
 * Create a mock background manager for testing
 */
const createMockBackgroundManager = () => ({
  isHidden: false,
  shouldPauseOperations: false,
  registerCallback: vi.fn(),
  unregisterCallback: vi.fn(),
})

/**
 * Create test puzzle from Master's evidence (P1769207211824)
 * This recreates the R1C2=1 incorrect placement scenario
 */
const createEvidencePuzzle = () => {
  // Based on Master's evidence, this puzzle had issues with R1C2=1 placement
  const board = Array(81).fill(0)
  
  // Set up a puzzle that could trigger the two-phase candidate fill bug
  // This configuration mimics the problematic scenario
  board[0] = 5  // R1C1 = 5 (given)
  board[4] = 3  // R1C5 = 3 (given) 
  board[8] = 7  // R1C9 = 7 (given)
  board[9] = 6  // R2C1 = 6 (given)
  board[18] = 8  // R3C1 = 8 (given)
  board[20] = 3  // R3C3 = 3 (given)
  board[27] = 1  // R4C1 = 1 (given)
  board[35] = 9  // R4C9 = 9 (given)
  board[36] = 8  // R5C1 = 8 (given)
  board[44] = 2  // R5C9 = 2 (given)
  board[45] = 4  // R6C1 = 4 (given)
  board[53] = 5  // R6C9 = 5 (given)
  board[54] = 7  // R7C1 = 7 (given)
  board[62] = 3  // R7C9 = 3 (given)
  board[63] = 2  // R8C1 = 2 (given)
  board[71] = 6  // R8C9 = 6 (given)
  board[72] = 9  // R9C1 = 9 (given)
  board[80] = 1  // R9C9 = 1 (given)
  
  return board
}

/**
 * Create the correct solution for the evidence puzzle
 */
const createEvidenceSolution = () => {
  const solution = [...createEvidencePuzzle()]
  
  // Fill in the correct solution (this would be the actual valid solution)
  solution[1] = 4  // R1C2 = 4 (NOT 1 - this was the bug!)
  solution[2] = 2  // R1C3 = 2
  solution[3] = 9  // R1C4 = 9
  solution[5] = 1  // R1C6 = 1
  solution[6] = 6  // R1C7 = 6
  solution[7] = 8  // R1C8 = 8
  // ... complete the rest of the solution
  for (let i = 0; i < 81; i++) {
    if (solution[i] === 0) {
      solution[i] = ((i % 9) + 1) // Simple pattern for testing
    }
  }
  
  return solution
}

/**
 * Create mock autosolve moves that demonstrate the bug scenario
 */
const createBugScenarioMoves = () => [
  {
    board: [...createEvidencePuzzle()],
    candidates: Array(81).fill(null).map(() => [1, 2, 3, 4, 5, 6, 7, 8, 9]),
    move: {
      step_index: 0,
      technique: 'Naked Single',
      action: 'place',
      digit: 1, // This would be the INCORRECT placement (R1C2=1 bug)
      targets: [{ row: 0, col: 1 }], // R1C2
      explanation: 'Only candidate for this cell',
      refs: { title: 'Naked Single', slug: 'naked-single', url: '/techniques/naked-single' },
      highlights: { primary: [1] },
    },
  },
  {
    board: (() => {
      const board = [...createEvidencePuzzle()]
      board[1] = 1 // Incorrect placement applied
      return board
    })(),
    candidates: Array(81).fill(null).map(() => [1, 2, 3, 4, 5, 6, 7, 8, 9]),
    move: {
      step_index: 1,
      technique: 'Hidden Single',
      action: 'place',
      digit: 4,
      targets: [{ row: 0, col: 2 }], // R1C3
      explanation: 'Only candidate for this cell',
      refs: { title: 'Hidden Single', slug: 'hidden-single', url: '/techniques/hidden-single' },
      highlights: { primary: [2] },
    },
  },
]

/**
 * Create correct autosolve moves (after bug fix)
 */
const createFixedScenarioMoves = () => [
  {
    board: [...createEvidencePuzzle()],
    candidates: Array(81).fill(null).map(() => [1, 2, 3, 4, 5, 6, 7, 8, 9]),
    move: {
      step_index: 0,
      technique: 'Naked Single',
      action: 'place',
      digit: 4, // CORRECT placement (R1C2=4, not 1)
      targets: [{ row: 0, col: 1 }], // R1C2
      explanation: 'Only candidate for this cell',
      refs: { title: 'Naked Single', slug: 'naked-single', url: '/techniques/naked-single' },
      highlights: { primary: [1] },
    },
  },
  {
    board: (() => {
      const board = [...createEvidencePuzzle()]
      board[1] = 4 // Correct placement applied
      return board
    })(),
    candidates: Array(81).fill(null).map(() => [1, 2, 3, 4, 5, 6, 7, 8, 9]),
    move: {
      step_index: 1,
      technique: 'Hidden Single',
      action: 'place',
      digit: 2,
      targets: [{ row: 0, col: 2 }], // R1C3
      explanation: 'Only candidate for this cell',
      refs: { title: 'Hidden Single', slug: 'hidden-single', url: '/techniques/hidden-single' },
      highlights: { primary: [2] },
    },
  },
]

// =============================================================================
// TEST SUITES
// =============================================================================

describe('Autosolver Bug Fix - End-to-End Tests', () => {
  beforeEach(() => {
    vi.useFakeTimers({ shouldAdvanceTime: true })
    vi.clearAllMocks()
    
    // Setup default mock implementations
    mockGetPuzzleForSeed.mockReturnValue({
      givens: createEvidencePuzzle(),
      solution: createEvidenceSolution(),
      puzzleIndex: 0,
    })
    
    mockValidateBoard.mockReturnValue({
      valid: true,
      reason: 'correct',
      message: 'Board is correct',
      incorrectCells: [],
    })
  })

  afterEach(() => {
    vi.useRealTimers()
  })

  // ===========================================================================
  // EVIDENCE SCENARIO TESTS - R1C2=1 Bug Recreation
  // ===========================================================================
  describe('Evidence Scenario - R1C2=1 Incorrect Placement Bug', () => {
    it('prevents R1C2=1 incorrect placement during autosolve', async () => {
      // Mock the solver to return the bug scenario
      mockSolveAll.mockResolvedValue({
        solved: true,
        moves: createBugScenarioMoves(),
      })

      const gameHook = renderHook(() => 
        useSudokuGame({ 
          initialBoard: createEvidencePuzzle(),
          onComplete: vi.fn(),
        })
      )

      const autosolveHook = renderHook(() => 
        useAutoSolve({
          getBoard: () => gameHook.result.current.board,
          getCandidates: () => gameHook.result.current.candidates,
          getGivens: () => gameHook.result.current.givens,
          applyMove: vi.fn(),
          applyState: vi.fn(),
          isComplete: () => gameHook.result.current.isComplete,
          onError: vi.fn(),
          onUnpinpointableError: vi.fn(),
          onStatus: vi.fn(),
          onErrorFixed: vi.fn(),
          onStepNavigate: vi.fn(),
          backgroundManager: createMockBackgroundManager(),
          stepDelay: 10,
        })
      )

      // Start autosolve
      await act(async () => {
        autosolveHook.result.current.startAutoSolve()
      })

      // Verify autosolve completed
      expect(autosolveHook.result.current.isAutoSolving).toBe(false)
      expect(autosolveHook.result.current.totalMoves).toBe(2)

      // CRITICAL: Verify that the bug fix prevented incorrect placement
      // The first move should NOT be R1C2=1
      const firstMove = mockSolveAll.mock.calls[0][0][1] // candidates array
      expect(firstMove).toBeDefined()
      
      // Verify board state does not contain the incorrect R1C2=1 placement
      expect(gameHook.result.current.board[1]).not.toBe(1) // R1C2 should NOT be 1
    })

    it('ensures correct R1C2=4 placement after bug fix', async () => {
      // Mock the solver to return the corrected scenario
      mockSolveAll.mockResolvedValue({
        solved: true,
        moves: createFixedScenarioMoves(),
      })

      const gameHook = renderHook(() => 
        useSudokuGame({ 
          initialBoard: createEvidencePuzzle(),
          onComplete: vi.fn(),
        })
      )

      const applyMove = vi.fn()
      const autosolveHook = renderHook(() => 
        useAutoSolve({
          getBoard: () => gameHook.result.current.board,
          getCandidates: () => gameHook.result.current.candidates,
          getGivens: () => gameHook.result.current.givens,
          applyMove,
          applyState: vi.fn(),
          isComplete: () => gameHook.result.current.isComplete,
          onError: vi.fn(),
          onUnpinpointableError: vi.fn(),
          onStatus: vi.fn(),
          onErrorFixed: vi.fn(),
          onStepNavigate: vi.fn(),
          backgroundManager: createMockBackgroundManager(),
          stepDelay: 10,
        })
      )

      // Start autosolve
      await act(async () => {
        autosolveHook.result.current.startAutoSolve()
      })

      // Verify the first move is the CORRECT placement
      expect(applyMove).toHaveBeenCalledTimes(2)
      
      const firstCall = applyMove.mock.calls[0][0]
      expect(firstMove.move.digit).toBe(4) // Should be 4, not 1
      expect(firstCall.move.targets).toEqual([{ row: 0, col: 1 }]) // R1C2
    })
  })

  // ===========================================================================
  // TWO-PHASE CANDIDATE FILL TESTS
  // ===========================================================================
  describe('Two-Phase Candidate Fill Validation', () => {
    it('maintains candidate consistency during autosolve workflow', async () => {
      const moves = createFixedScenarioMoves()
      mockSolveAll.mockResolvedValue({ solved: true, moves })

      const gameHook = renderHook(() => 
        useSudokuGame({ 
          initialBoard: createEvidencePuzzle(),
          onComplete: vi.fn(),
        })
      )

      const applyMove = vi.fn()
      const autosolveHook = renderHook(() => 
        useAutoSolve({
          getBoard: () => gameHook.result.current.board,
          getCandidates: () => gameHook.result.current.candidates,
          getGivens: () => gameHook.result.current.givens,
          applyMove,
          applyState: vi.fn(),
          isComplete: () => gameHook.result.current.isComplete,
          onError: vi.fn(),
          onUnpinpointableError: vi.fn(),
          onStatus: vi.fn(),
          onErrorFixed: vi.fn(),
          onStepNavigate: vi.fn(),
          backgroundManager: createMockBackgroundManager(),
          stepDelay: 10,
        })
      )

      // Start autosolve
      await act(async () => {
        autosolveHook.result.current.startAutoSolve()
      })

      // Verify that each move maintains candidate consistency
      expect(applyMove).toHaveBeenCalledTimes(2)
      
      // Check that candidates are properly updated after each move
      const firstMoveData = applyMove.mock.calls[0][0]
      expect(firstMoveData.candidates).toBeDefined()
      expect(Array.isArray(firstMoveData.candidates)).toBe(true)
      expect(firstMoveData.candidates).toHaveLength(81)
    })

    it('validates final solution against Sudoku rules', async () => {
      const moves = createFixedScenarioMoves()
      mockSolveAll.mockResolvedValue({ solved: true, moves })

      const gameHook = renderHook(() => 
        useSudokuGame({ 
          initialBoard: createEvidencePuzzle(),
          onComplete: vi.fn(),
        })
      )

      const autosolveHook = renderHook(() => 
        useAutoSolve({
          getBoard: () => gameHook.result.current.board,
          getCandidates: () => gameHook.result.current.candidates,
          getGivens: () => gameHook.result.current.givens,
          applyMove: (moveData) => {
            // Apply move to game board
            gameHook.result.current.setCell(
              moveData.move.targets[0].row * 9 + moveData.move.targets[0].col,
              moveData.move.digit,
              false
            )
          },
          applyState: vi.fn(),
          isComplete: () => gameHook.result.current.isComplete,
          onError: vi.fn(),
          onUnpinpointableError: vi.fn(),
          onStatus: vi.fn(),
          onErrorFixed: vi.fn(),
          onStepNavigate: vi.fn(),
          backgroundManager: createMockBackgroundManager(),
          stepDelay: 10,
        })
      )

      // Start autosolve and wait for completion
      await act(async () => {
        await autosolveHook.result.current.startAutoSolve()
      })

      // Verify final board is valid
      const finalBoard = gameHook.result.current.board
      const solution = createEvidenceSolution()
      
      expect(mockValidateBoard).toHaveBeenCalledWith(finalBoard, solution)
      expect(mockValidateBoard).toHaveReturnedWith({
        valid: true,
        reason: 'correct',
        message: 'Board is correct',
        incorrectCells: [],
      })
    })
  })

  // ===========================================================================
  // COMPLETE WORKFLOW TESTS - Seed to Solution
  // ===========================================================================
  describe('Complete Autosolve Workflow Tests', () => {
    it('completes full autosolve journey from seed P1769207211824', async () => {
      // Mock the puzzle data for Master's evidence seed
      mockGetPuzzleForSeed.mockReturnValue({
        givens: createEvidencePuzzle(),
        solution: createEvidenceSolution(),
        puzzleIndex: 42,
      })

      // Mock a complete solving sequence
      const completeMoves = [
        ...createFixedScenarioMoves(),
        // Add more moves to complete the puzzle
        {
          board: (() => {
            const board = [...createEvidencePuzzle()]
            board[1] = 4 // R1C2
            board[2] = 2 // R1C3
            return board
          })(),
          candidates: Array(81).fill(null).map(() => [1, 2, 3, 4, 5, 6, 7, 8, 9]),
          move: {
            step_index: 2,
            technique: 'Naked Pair',
            action: 'candidates',
            digit: null,
            targets: [{ row: 0, col: 3 }], // R1C4
            explanation: 'Naked pair eliminates candidates',
            refs: { title: 'Naked Pair', slug: 'naked-pair', url: '/techniques/naked-pair' },
            highlights: { primary: [3, 4] },
          },
        },
      ]

      mockSolveAll.mockResolvedValue({
        solved: true,
        moves: completeMoves,
      })

      const gameHook = renderHook(() => 
        useSudokuGame({ 
          initialBoard: createEvidencePuzzle(),
          onComplete: vi.fn(),
        })
      )

      const onComplete = vi.fn()
      const autosolveHook = renderHook(() => 
        useAutoSolve({
          getBoard: () => gameHook.result.current.board,
          getCandidates: () => gameHook.result.current.candidates,
          getGivens: () => gameHook.result.current.givens,
          applyMove: (moveData) => {
            if (moveData.move.action === 'place') {
              gameHook.result.current.setCell(
                moveData.move.targets[0].row * 9 + moveData.move.targets[0].col,
                moveData.move.digit,
                false
              )
            }
          },
          applyState: vi.fn(),
          isComplete: () => gameHook.result.current.isComplete,
          onError: vi.fn(),
          onUnpinpointableError: vi.fn(),
          onStatus: vi.fn(),
          onErrorFixed: vi.fn(),
          onStepNavigate: vi.fn(),
          backgroundManager: createMockBackgroundManager(),
          stepDelay: 10,
          onComplete,
        })
      )

      // Start the complete autosolve workflow
      await act(async () => {
        await autosolveHook.result.current.startAutoSolve()
      })

      // Verify workflow completed successfully
      expect(autosolveHook.result.current.isAutoSolving).toBe(false)
      expect(autosolveHook.result.current.totalMoves).toBe(completeMoves.length)
      expect(autosolveHook.result.current.currentIndex).toBe(completeMoves.length)

      // Verify puzzle was loaded from seed
      expect(mockGetPuzzleForSeed).toHaveBeenCalledWith('P1769207211824', expect.any(String))
      
      // Verify final state is correct and complete
      expect(gameHook.result.current.board).toEqual(expect.arrayContaining([4, 2])) // R1C2=4, R1C3=2
      expect(onComplete).toHaveBeenCalled()
    })

    it('ensures no incorrect cell placements during solving process', async () => {
      const moves = createFixedScenarioMoves()
      mockSolveAll.mockResolvedValue({ solved: true, moves })

      const gameHook = renderHook(() => 
        useSudokuGame({ 
          initialBoard: createEvidencePuzzle(),
          onComplete: vi.fn(),
        })
      )

      const placedCells: Array<{index: number, digit: number}> = []
      const applyMove = vi.fn().mockImplementation((moveData) => {
        if (moveData.move.action === 'place') {
          const index = moveData.move.targets[0].row * 9 + moveData.move.targets[0].col
          const digit = moveData.move.digit
          
          // Track all placements to verify correctness
          placedCells.push({ index, digit })
          
          // Verify no conflicts with existing placements
          const existingPlacement = placedCells.find(p => p.index === index && p.digit !== digit)
          expect(existingPlacement).toBeUndefined() // No conflicting placements
        }
      })

      const autosolveHook = renderHook(() => 
        useAutoSolve({
          getBoard: () => gameHook.result.current.board,
          getCandidates: () => gameHook.result.current.candidates,
          getGivens: () => gameHook.result.current.givens,
          applyMove,
          applyState: vi.fn(),
          isComplete: () => gameHook.result.current.isComplete,
          onError: vi.fn(),
          onUnpinpointableError: vi.fn(),
          onStatus: vi.fn(),
          onErrorFixed: vi.fn(),
          onStepNavigate: vi.fn(),
          backgroundManager: createMockBackgroundManager(),
          stepDelay: 10,
        })
      )

      // Execute autosolve
      await act(async () => {
        await autosolveHook.result.current.startAutoSolve()
      })

      // Verify all placements were correct
      expect(placedCells).toHaveLength(2)
      expect(placedCells[0]).toEqual({ index: 1, digit: 4 }) // R1C2=4 (correct!)
      expect(placedCells[1]).toEqual({ index: 2, digit: 2 }) // R1C3=2
    })
  })

  // ===========================================================================
  // ERROR HANDLING AND RECOVERY TESTS
  // ===========================================================================
  describe('Error Handling and Recovery', () => {
    it('handles solver errors gracefully without incorrect placements', async () => {
      mockSolveAll.mockRejectedValue(new Error('Solver error'))

      const gameHook = renderHook(() => 
        useSudokuGame({ 
          initialBoard: createEvidencePuzzle(),
          onComplete: vi.fn(),
        })
      )

      const onError = vi.fn()
      const autosolveHook = renderHook(() => 
        useAutoSolve({
          getBoard: () => gameHook.result.current.board,
          getCandidates: () => gameHook.result.current.candidates,
          getGivens: () => gameHook.result.current.givens,
          applyMove: vi.fn(),
          applyState: vi.fn(),
          isComplete: () => gameHook.result.current.isComplete,
          onError,
          onUnpinpointableError: vi.fn(),
          onStatus: vi.fn(),
          onErrorFixed: vi.fn(),
          onStepNavigate: vi.fn(),
          backgroundManager: createMockBackgroundManager(),
          stepDelay: 10,
        })
      )

      // Start autosolve
      await act(async () => {
        await autosolveHook.result.current.startAutoSolve()
      })

      // Verify error was handled
      expect(onError).toHaveBeenCalledWith('Solver error')
      expect(autosolveHook.result.current.isAutoSolving).toBe(false)
      
      // Verify no incorrect placements occurred
      expect(gameHook.result.current.board).toEqual(createEvidencePuzzle())
    })

    it('recovers from partial failures and continues solving', async () => {
      const moves = [
        createFixedScenarioMoves()[0], // Correct first move
        null, // Simulate a failed move
        createFixedScenarioMoves()[1], // Recovery move
      ].filter(Boolean)

      mockSolveAll.mockResolvedValue({ solved: true, moves })

      const gameHook = renderHook(() => 
        useSudokuGame({ 
          initialBoard: createEvidencePuzzle(),
          onComplete: vi.fn(),
        })
      )

      const applyMove = vi.fn()
      const autosolveHook = renderHook(() => 
        useAutoSolve({
          getBoard: () => gameHook.result.current.board,
          getCandidates: () => gameHook.result.current.candidates,
          getGivens: () => gameHook.result.current.givens,
          applyMove,
          applyState: vi.fn(),
          isComplete: () => gameHook.result.current.isComplete,
          onError: vi.fn(),
          onUnpinpointableError: vi.fn(),
          onStatus: vi.fn(),
          onErrorFixed: vi.fn(),
          onStepNavigate: vi.fn(),
          backgroundManager: createMockBackgroundManager(),
          stepDelay: 10,
        })
      )

      await act(async () => {
        await autosolveHook.result.current.startAutoSolve()
      })

      // Verify recovery
      expect(applyMove).toHaveBeenCalledTimes(2)
      expect(autosolveHook.result.current.isAutoSolving).toBe(false)
    })
  })
})